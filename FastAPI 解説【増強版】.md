

### FastAPI 解説【増強版】

Pythonの基礎を学び終えた皆さん、次のステップへようこそ！
このドキュメントでは、今最も注目されているPythonのWebフレームワークの一つである**FastAPI**について、その魅力から実際の使い方まで、一つひとつ丁寧に解説していきます。専門用語も出てきますが、その都度かみ砕いて説明するので、安心して読み進めてください。

#### そもそも「API」や「Webフレームワーク」って何？

本題に入る前に、基本的な言葉の意味を整理しましょう。

*   **API (Application Programming Interface)**:
    一言で言うと、**「プログラム同士が会話するための窓口」**です。
    例えば、あなたが天気予報アプリを使うとき、アプリは気象庁のコンピューター（サーバー）にある天気データにアクセスします。このとき、アプリが気象庁のサーバーに「東京の天気を教えて！」とお願いし、サーバーが「晴れです」と答える、このやり取りのルールがAPIです。FastAPIは、このような「窓口」を非常に速く、簡単に作るための道具です。

*   **Webフレームワーク**:
    **「Webアプリケーションを効率よく作るための骨組みと道具のセット」**です。家を建てる時、ゼロから木を切って釘を作るのではなく、柱や壁などの骨組み、トンカチやノコギリといった道具を使いますよね。Webフレームワークは、その骨組みや道具を提供してくれ、開発者は「どんな部屋を作るか」という本質的な部分に集中できます。

---

### 1. FastAPIとは？ その核心に迫る

**FastAPI**は、Python 3.7以降の「型ヒント」という機能をフル活用して作られた、モダンで非常に高性能なWebフレームワークです。その名の通り、「Fast（速い）」ことが最大の特長で、これは**「プログラムの実行速度」**と**「開発のスピード」**の両方を指します。

#### 1.1. FastAPIを支える2本の柱：StarletteとPydantic

FastAPIのすごさは、単独で生まれたものではなく、2つの強力なライブラリを「いいとこ取り」して作られている点にあります。これを理解することが、FastAPIを理解する一番の近道です。

レストランの厨房に例えてみましょう。FastAPIは、優秀なスタッフが揃った「レストラン全体」です。

*   **Starlette (パフォーマンス担当)**: レストランの**「超敏腕フロアマネージャー」**です。
    Starletteは、**ASGI (Asynchronous Server Gateway Interface)** という仕組みに対応した、非常に高速なWebツールキットです。
    *   **ASGIって何？**: 「**非同期**でリクエストを処理するためのルール」です。
    *   **非同期って何？**: 料理人がパスタを茹でている9分間、ただ待っているのではなく、その間にサラダの準備やソース作りを進めるような働き方です。一つの重い処理（I/O処理、※後述）で手が止まらず、待ち時間に他の仕事を並行してこなせるため、サーバー全体として非常に効率が良くなります。
    FastAPIは、このStarletteのおかげで、お客様（クライアント）からの大量の注文（リクエスト）をテキパキとさばくことができるのです。

*   **Pydantic (データバリデーションと設定管理担当)**: レストランの**「超厳格なレシピチェック係」**です。
    Pydanticは、Pythonの**型ヒント**を使って、データの正しさをチェック（**バリデーション**）してくれるライブラリです。
    *   **型ヒントって何？**: 変数や関数の引数が「どんな種類のデータか（数値、文字列など）」をあらかじめ示しておく機能です。 `name: str` のように書きます。
    *   **バリデーションって何？**: データが正しい形式やルールに従っているか検証することです。例えば、「年齢」という項目に文字列（"二十歳"など）が入っていたらエラーにする、といったチェックです。
    Pydanticは、この型ヒントを見るだけで、APIに送られてきたデータが「レシピ（決められたルール）」通りか自動で厳しくチェックしてくれます。もしレシピにない食材（不正なデータ）が届いたら、「これは受け取れません！」と門前払いしてくれるので、厨房の中（プログラム本体）は安全です。

つまり、**FastAPI = Starlette (高速な接客) + Pydantic (厳格なレシピチェック) + α (API開発に便利な機能群)** という関係性で理解すると、その本質を捉えやすくなります。

#### 1.2. 主な特徴

FastAPIには、現代のWeb開発で「あったら嬉しい」機能が最初から全部入りしています。

*   **高性能**: 非同期処理のおかげで、Python製フレームワークの中ではトップクラスの処理速度を誇ります。たくさんのアクセスにも耐えられます。
*   **開発速度の向上**: コードを書く量が少なく、直感的です。型ヒントのおかげで、エディタ（VSCodeなど）が「次は何を書けばいい？」と賢く予測変換（コード補完）してくれるので、タイピングミスも減り、開発がサクサク進みます。
*   **バグの削減**: Pydanticが入り口でデータを厳しくチェックしてくれるため、予期せぬデータによるエラーが激減します。開発者は安心してビジネスロジック（本当にやりたいこと）の実装に集中できます。
*   **自動対話的ドキュメント**: これが最高に便利です！コードを書くだけで、APIの仕様書（ドキュメント）が**自動で生成**されます。しかも、ただの文書ではなく、ブラウザ上で実際にAPIを試せる「動く仕様書」です。
*   **標準への準拠**: OpenAPIやJSON Schemaといった、API界の「世界標準規格」に準拠しています。これにより、様々なツールとスムーズに連携できます。
*   **強力な依存性注入（Dependency Injection）システム**: 少し難しい言葉ですが、**「役割分担をうまくやるための仕組み」**です。データベース接続のような共通処理を部品化して、必要な場所で簡単に呼び出せるようにします。後の章で詳しく解説します。

---

### 2. なぜFastAPIが選ばれるのか？ そのメリットを深掘り

DjangoやFlaskといった有名な先輩フレームワークがある中で、なぜ多くの開発者がFastAPIを選ぶのでしょうか。

#### 2.1. メリット1：圧倒的なパフォーマンス

Web APIの応答速度は、ユーザー体験に直結します。FastAPIは、**ASGI**という仕組みで動くことで、高いパフォーマンスを実現します。

*   **ASGI vs WSGI**: 昔の主流だった**WSGI**は「同期的」でした。これは、一人の店員が一人の客の注文を全て終えるまで、次の客を待たせてしまうような働き方です。一方、**ASGI**は「非同期」なので、複数の客の対応を保留したり並行したりしながら、効率よく店全体を回せます。
*   **I/Oバウンドな処理**: データベースへの問い合わせや、他のAPIの呼び出しなど、CPUは暇なのに「待ち時間」が発生する処理を「I/Oバウンド」と言います。ASGIは、この待ち時間を有効活用するのが得意です。
*   **Uvicorn**: FastAPIを動かす際によく使われる、ASGIに対応した超高速なWebサーバーです。FastAPIとUvicornは最高のコンビです。

#### 2.2. メリット2：爆発的な開発スピードと生産性

FastAPIは「開発者の体験」をとても大切にしています。

**直感的で簡潔なコード:**
たったこれだけのコードで、信じられないほど多くのことを実現できます。

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional # Python 3.10未満でオプショナルな型を使う場合に必要

app = FastAPI()

# 「Item」というデータの設計図をPydanticで定義
class Item(BaseModel):
    name: str  # nameは文字列で、必須
    price: float # priceは浮動小数点数で、必須
    is_offer: bool | None = None # is_offerはブール値(True/False)かNone。= Noneなので任意項目。

# "/items/"という住所(エンドポイント)にPOSTメソッドでリクエストが来た時の処理
@app.post("/items/")
async def create_item(item: Item): # リクエストの本文(ボディ)をItemモデルとして受け取る
    return item
```

上の短いコードが、裏側でやってくれることは以下の通りです。

1.  `/items/` というURL（**エンドポイント**と呼びます）への**POSTリクエスト**を待ち受けます。
2.  送られてきたデータがJSON形式であることを自動で認識します。
3.  JSONデータの中身を`Item`クラスの定義通りかチェックします。（`name`は文字列か？ `price`は数値か？）
4.  もし`price`が`"高い"`のような文字列だったら、「それはルール違反です」という内容の**HTTP 422エラー**を自動で返してくれます。
5.  チェックを通過したら、受け取ったデータを`item`というPythonオブジェクトに変換してくれるので、`item.name`のように簡単にアクセスできます。
6.  エディタが`item`が`Item`クラスのインスタンスだと理解しているので、`item.`と打った瞬間に`name`や`price`といった属性を候補として表示してくれます（これが非常に便利！）。
7.  関数が返した`item`オブジェクトを、再びJSON形式に変換して、リクエスト元に返信します。

これだけのことを、わずか数行の宣言的なコードで実現できるのがFastAPIの強みです。

#### 2.3. メリット3：ヒューマンエラーの削減と堅牢性の向上

プログラムのエラーはつきものですが、FastAPIはそれを未然に防いだり、原因を特定しやすくしたりする仕組みが満載です。

*   **実行前チェック (静的解析)**: `mypy`のような型チェックツールを使えば、プログラムを実行する前に「この関数は数値を期待しているのに、文字列を渡そうとしているよ」といった間違いを見つけられます。
*   **実行時チェック (バリデーション)**: Pydanticによる実行時のデータチェックがとにかく強力です。想定外のデータがプログラムの心臓部に到達する前にブロックしてくれる「頼れる門番」がいるようなものです。

#### 2.4. メリット4："動く"ドキュメントの自動生成

API開発では、仕様書の作成と更新が地味に大変な作業です。FastAPIはこの問題を革命的に解決します。

サーバーを起動して `/docs` というURLにアクセスすると **Swagger UI** が、`/redoc` にアクセスすると **ReDoc** という、2種類のAPIドキュメントが自動で表示されます。

*   **常に最新**: コードを修正すれば、ドキュメントもリアルタイムで更新されます。「仕様書と実装が違う」という悲劇が起こりません。
*   **対話的**: Swagger UIはただのドキュメントではありません。ブラウザ上でパラメータを入力し「Execute」ボタンを押すだけで、実際にAPIを叩いて結果を確認できます。フロントエンド開発者や他のチームメンバーが、気軽にAPIの動作を試せるため、コミュニケーションが非常にスムーズになります。

---

### 3. FastAPI実践入門：ゼロから始めるAPI開発

理屈はここまでにして、実際に手を動かしてみましょう！

#### 3.1. 環境構築

1.  **Pythonのインストール**: Python 3.7以降を準備してください。

2.  **仮想環境の作成**: プロジェクトごとにライブラリを管理するためのお作法です。プロジェクト専用の「道具箱」を作るイメージです。

    ```bash
    # プロジェクト用のフォルダを作成して移動
    mkdir fastapi_project
    cd fastapi_project

    # 仮想環境を作成 (venvはPythonの標準機能)
    python -m venv venv

    # 仮想環境を有効化（このコマンドを実行すると、ターミナルの表示が変わります）
    # Windowsの場合:
    # venv\Scripts\activate
    # macOS/Linuxの場合:
    # source venv/bin/activate
    ```

3.  **FastAPIとUvicornのインストール**: FastAPI本体と、それを動かすためのASGIサーバーUvicornをインストールします。

    ```bash
    pip install fastapi "uvicorn[standard]"
    ```
    `"uvicorn[standard]"`と指定することで、パフォーマンスを向上させる追加ライブラリも一緒にインストールされ、Uvicornが本気を出せるようになります。

#### 3.2. はじめてのFastAPIアプリケーション

`main.py`という名前でファイルを作成し、以下のコードを書きましょう。

```python
# main.py
from fastapi import FastAPI

# FastAPIのインスタンス（本体）を作成
app = FastAPI()

# 「デコレータ」と呼ばれるもので、関数の上につける「飾り」のようなもの。
# これにより、すぐ下の関数が「どのURL」で「どのHTTPメソッド」の処理を担当するかを指定します。
@app.get("/")
# 「パスオペレーション関数」：上記で指定されたURLへのリクエストを実際に処理する関数
# async をつけると「非同期関数」になり、効率的な処理が可能になります。
async def read_root():
    # Pythonの辞書を返すと、FastAPIが自動でJSON形式に変換してくれます。
    return {"Hello": "World"}
```

*   **`@app.get("/")`**: これは**デコレータ**と呼ばれるPythonの機能です。関数に特別な機能を与える「魔法の帽子」のようなものだと考えてください。この場合、「`/`（ルートURL）への**GETリクエスト**が来たら、すぐ下の`read_root`関数を呼び出してね」という役割を与えています。
*   **`async def`**: `async`キーワードをつけると、その関数は「非同期関数」になります。重い処理があっても他の処理をブロックしない、効率的な関数です。最初は難しく考えず、「FastAPIではよく使うおまじない」くらいに思ってOKです。もちろん、`def`だけの同期関数も使えます。

#### 3.3. アプリケーションの実行

ターミナルで以下のコマンドを実行します。

```bash
uvicorn main:app --reload
```

*   `main`: `main.py` ファイル（モジュール）のこと。
*   `app`: `main.py` の中で `app = FastAPI()` と書いたインスタンス（本体）のこと。
*   `--reload`: 開発中に非常に便利なオプション。コードを保存するたびに、サーバーが自動で再起動します。

ターミナルに `Uvicorn running on http://127.0.0.1:8000` のようなメッセージが表示されたら成功です！

#### 3.4. 動作確認と自動ドキュメント

*   **APIの確認**: Webブラウザで `http://127.0.0.1:8000/` にアクセスしてください。`{"Hello":"World"}`というJSONが表示されるはずです。
*   **Swagger UI**: 次に、`http://127.0.0.1:8000/docs` にアクセスしてください。自動生成された、リッチで対話的なAPIドキュメントが表示されます。感動の瞬間です！
*   **ReDoc**: `http://127.0.0.1:8000/redoc` にアクセスすると、もう一つの見た目が異なるドキュメントが表示されます。

---

### 4. パスの種類とパラメータの扱い方

APIは、URLを通じて様々な情報を受け取ります。その受け取り方を学びましょう。

#### 4.1. パスパラメータ

URLの一部を変動させたいときに使います。例えば、特定のIDを持つ商品ページなどです。

```python
# main.py (追記)

# {item_id} の部分がパスパラメータ。URLによって変わる値が入る場所。
@app.get("/items/{item_id}")
# 関数の引数に、パスパラメータと同じ名前で、型ヒントを付けて変数を定義する。
async def read_item(item_id: int):
    return {"item_id": item_id}
```

*   `item_id: int`: 型ヒントを `int` (整数) に指定したのがポイントです。
*   **自動バリデーション**:
    *   `http://127.0.0.1:8000/items/5` のようにアクセスすると、`item_id`に整数の`5`が渡されます。
    *   `http://127.0.0.1:8000/items/apple` のように整数でない値でアクセスすると、FastAPIが「整数じゃないとダメですよ！」と自動でエラー（HTTP 422）を返してくれます。

#### 4.2. クエリパラメータ

URLの `?` 以降に続く `キー=値` の形式のパラメータです。検索、絞り込み、並び替えなどによく使われます。

```python
# main.py (追記)

# 存在しないユーザーDBのダミー
fake_users_db = [{"user_id": 1}, {"user_id": 2}, {"user_id": 3}, {"user_id": 4}]

@app.get("/users/")
# パスに定義されていない引数は、クエリパラメータとして扱われる。
# デフォルト値を設定することで、任意項目になる。
async def read_users(skip: int = 0, limit: int = 10):
    return fake_users_db[skip : skip + limit]
```

*   **動作**:
    *   `http://127.0.0.1:8000/users/` → デフォルト値が使われ `skip=0, limit=10`
    *   `http://127.0.0.1:8000/users/?skip=1&limit=2` → `skip=1, limit=2` として扱われ、`[{"user_id": 2}, {"user_id": 3}]`が返されます。
*   ここでも型ヒントが有効で、`skip`に文字列などを渡そうとするとエラーになります。

#### 4.3. リクエストボディとPydanticモデル

POSTやPUTメソッドなどで、より複雑なデータをクライアントから受け取るには、**リクエストボディ**を使います。手紙で言えば「本文」の部分です。FastAPIでは、この「本文」のフォーマットをPydanticモデルで定義します。

`main.py`を以下のように修正しましょう。

```python
# main.py
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional # Python 3.9以前では必須

# PydanticのBaseModelを継承して、データの設計図(スキーマ)を作る
class Item(BaseModel):
    name: str
    description: str | None = None  # 文字列またはNone。= Noneで任意項目に。
    price: float
    tax: float | None = None

app = FastAPI()

@app.post("/items/")
# 引数の型ヒントに、作成したPydanticモデルを指定する
async def create_item(item: Item):
    item_dict = item.model_dump() # Pydantic v2では .model_dump()
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict
```

*   **`class Item(BaseModel):`**: これがリクエストボディの構造を定義する**Pydanticモデル**です。クラスの属性として、欲しいデータの名前と型を定義します。
*   **`async def create_item(item: Item):`**: 関数の引数 `item` の型を、先ほど定義した `Item` モデルに指定します。
*   **FastAPIの魔法**:
    1.  `/items/` へのPOSTリクエストが来ると、FastAPIはリクエストボディ（JSONデータ）を取り出します。
    2.  そのJSONデータを `Item` モデルのルールに従って検証します。
    3.  `name` がない、`price` が数値じゃない、などの不備があれば、どこがどう間違っているか詳細に記載されたエラーを自動で返します。
    4.  全てのチェックをパスすれば、JSONデータを `Item` クラスのインスタンスに変換し、`item` 引数に渡してくれます。

`/docs` のSwagger UIで、このPOSTエンドポイントを試してみてください。「Try it out」を押すとJSONのテンプレートが表示されるので、わざと `price` に文字列を入れるなどして、FastAPIがいかに賢くエラーを出してくれるかを確認できます。

---

*（ドキュメントが非常に長くなるため、以降のセクションは要点を絞って増強します。同様のスタイルで、各専門用語や概念に丁寧な解説を加えていきます。）*

### 5. Pydanticによる高度なバリデーションとデータ制御 (ダイジェスト)

Pydanticは、さらに細かいルールを設定できます。`Query`や`Path`を使って、数値の範囲や文字列の長さを指定できます。

*   **`Query`, `Path`**: パラメータに「最小値は1」「文字列は3文字以上50文字未満」といった、型だけでは表現できない制約を追加するための道具です。
*   **`Annotated`**: Python 3.9からの新機能で、「型ヒントに対する補足説明の付箋」のようなものです。`Annotated[int, Path(ge=1)]` のように書くと、「この変数は整数で、かつ1以上（`ge=1`）であるべき」という意味になります。
*   **`response_model`**: APIが返すレスポンスの形を定義します。これは非常に重要で、例えばユーザー情報のデータにパスワードのハッシュ値が含まれていても、`response_model`で公開するフィールドだけを指定すれば、**意図しない情報漏洩を防げます**。お客様に見せるお皿に、厨房の裏のメモ（パスワードなど）が乗らないようにする仕組みです。

```python
# レスポンスとして公開するデータモデル（パスワード情報を含まない）
class UserOut(BaseModel):
    username: str
    email: EmailStr

@app.post("/users/", response_model=UserOut)
async def create_user(user: UserInDB): # UserInDBはパスワード情報を含むモデル
    # ... DBに保存する処理 ...
    return user # UserInDBを返しても、UserOutモデルでフィルタリングされ安全
```

---

### 6. 依存性注入 (Dependency Injection / DI) (ダイジェスト)

これはFastAPIの最も強力でエレガントな機能です。難しそうに聞こえますが、**「面倒な仕事は専門家にお任せする仕組み」**と考えれば簡単です。

*   **コンセプト**: ある関数が何か（例: データベース接続）を必要とするとき、それを自分で用意するのではなく、外部から「注入」してもらいます。
*   **`Depends`**: 「この仕事は、この専門家（別の関数）にお願いします！」とFastAPIに伝えるための道具が `Depends` です。

**実践例：データベース接続の管理**
各APIエンドポイントで毎回データベースに接続して、処理が終わったら切断する、というコードを書くのは面倒で、忘れがちです。そこで、「データベース接続を管理する専門家」の関数（例: `get_db`）を作ります。

```python
# 専門家関数（依存性）
def get_db():
    db = SessionLocal() # DBセッションを開始
    try:
        yield db # ★ここでDBセッションを貸し出す
    finally:
        db.close() # ★処理が終わったら必ずセッションを閉じる

# APIエンドポイント
@app.get("/items/")
# Depends(get_db)で、DBのことはget_db専門家にお任せする
def read_items(db: Session = Depends(get_db)):
    # 注入されたdbを使って、DB操作に集中できる
    return db.query(models.Item).all()
```

*   **`yield`**: DIにおける `yield` は「貸し出し」と「返却」の合図です。`yield db` でAPI関数にDBセッションを貸し出し、API関数の処理が終わると `finally` 句に戻ってきて `db.close()` で確実に後片付け（返却）をしてくれます。
*   **メリット**:
    *   **コードの再利用**: `Depends(get_db)` と書くだけで、どのエンドポイントでも同じ仕組みを使えます。
    *   **関心の分離**: API関数は「DBをどうやって取得するか」を気にする必要がなくなり、本来のビジネスロジックに集中できます。
    *   **テストが容易**: テストの時は、本物のDBの代わりにテスト用の偽物DBを注入することが簡単にできます。

---

### 7. セキュリティ：認証と認可 (ダイジェスト)

APIを不正な利用から守る仕組みです。FastAPIはこれもDIシステムの上でスマートに実装できます。

*   **OAuth2.0 with Bearer Token**: 一般的な認証方式。「ユーザー名とパスワードを提示して**通行証（トークン）**をもらい、以降はその通行証を提示してAPIを利用する」という流れです。
*   **`OAuth2PasswordBearer`**: リクエストから通行証（トークン）を抜き出してくれる専門家です。
*   **実装の流れ**:
    1.  トークンを発行するためのエンドポイント (`/token`) を作る。
    2.  「通行証をチェックして、持ち主が誰かを確認する」専門家関数 (`get_current_user`) を作る。
    3.  保護したいエンドポイントで `Depends` を使って、この専門家を呼び出す。

```python
# 保護したいエンドポイント
@app.get("/users/me")
# get_current_active_user専門家が通行証をチェックし、OKならユーザー情報を返してくれる
async def read_users_me(current_user: User = Depends(get_current_active_user)):
    return current_user # ここに到達した時点で、ユーザーは認証済み
```
認証チェックのロジックを一つの専門家関数にまとめる（**カプセル化**する）ことで、安全でメンテナンスしやすいコードになります。

---

### 8. 大規模アプリケーションへの道：APIRouter (ダイジェスト)

プロジェクトが大きくなると、`main.py`が肥大化します。`APIRouter`は、関連するAPIエンドポイントを機能ごとにファイル分割するための道具です。

*   **考え方**: 会社が「営業部」「開発部」「経理部」と分かれているように、APIも「商品（items）」「ユーザー（users）」のようにファイルを分割します。
    *   `routers/items.py` ← 商品関連のAPI
    *   `routers/users.py` ← ユーザー関連のAPI
*   **`main.py`の役割**: `main.py`は会社の受付のように、各部署（ルーター）を束ねる役割を果たします。
*   **`app.include_router()`**: 各部署のルーターを、メインのアプリに登録する命令です。`prefix`を指定すれば「`/admin`以下のURLはこの部署が担当」といった設定もできます。

---

### 9. その他の高度な機能 (ダイジェスト)

*   **バックグラウンドタスク**: ユーザーにレスポンスを返した**後で**、メール送信などの時間のかかる処理を実行する機能。ユーザーを待たせる必要がありません。
*   **ミドルウェア**: 全てのリクエストが通る「関所」のようなもの。アクセスログの記録や、CORS（※）対応など、共通の処理を挟み込むのに使います。
    *   **CORS (Cross-Origin Resource Sharing)**: `http://localhost:3000` で動いているフロントエンドアプリから `http://localhost:8000` のAPIにアクセスする、といったドメインをまたいだ通信を許可するための設定です。
*   **テスト**: `TestClient` という非常に便利な道具が用意されており、実際のネットワークを介さずにAPIを高速にテストできます。DIのおかげで、テスト用の設定に切り替えるのも簡単です。

---

### 10. まとめ

FastAPIは、Pythonの現代的な機能（特に**型ヒント**）を最大限に活用し、以下の3つを高いレベルで実現した画期的なWebフレームワークです。

1.  **爆速の開発スピード**: 直感的なコード、強力なエディタ支援、そして何より**自動対話的ドキュメント**が開発体験を劇的に向上させます。
2.  **超高速な実行性能**: **Starlette**と**ASGI**を基盤とした非同期処理により、高負荷にも耐えうるパフォーマンスを発揮します。
3.  **高い信頼性と堅牢性**: **Pydantic**による厳格なデータバリデーションが、多くのバグを未然に防ぎます。

これらを実現する心臓部が、**強力な依存性注入（DI）システム**です。


まずはこのドキュメントで紹介した簡単なAPIを実際に自分の手で動かし、`/docs` の便利さを体験してみてください。きっと、あなたもFastAPIの虜になるはずです！
